---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 03-regression-variable-selection.md in _episodes_rmd/
title: "Feature selection for regression"
teaching: 45
exercises: 15
questions:
- "Why would we want to find a subset of features
  that are associated with an outcome?"
- "How should we *not* select features?"
- "How can we iteratively find a good subset of our features
  variables to use for regression?"
- "What are some risks and downsides of iterative feature
  selection?"
objectives:
- "Understand multiple regression in a biomedical context."
- "Understand how to fit a stepwise regression model."
keypoints:
- "Sets of features can be more predictive and provide
  a better explanation than a single feature alone."
- "Stepwise regression allows us to find a set of features that
  are associated with an outcome (eg, age)."
- "Stepwise regression is not very efficient."
# - "Stepwise regression will tend to retain only one
#   feature out of many that are correlated."
math: yes
---




# Intro

First, let's read in the data from the last lesson.



~~~
library("here")
library("minfi")
if (!file.exists(here("data/methylation.rds"))) {
    source(here("data/methylation.R"))
}
~~~
{: .language-r}



~~~
Error in loadNamespace(x): there is no package called 'methylclock'
~~~
{: .error}



~~~
methylation <- readRDS(here("data/methylation.rds"))
~~~
{: .language-r}



~~~
Warning in gzfile(file, "rb"): cannot open compressed file '/home/runner/
work/high-dimensional-stats-r/high-dimensional-stats-r/data/methylation.rds',
probable reason 'No such file or directory'
~~~
{: .warning}



~~~
Error in gzfile(file, "rb"): cannot open the connection
~~~
{: .error}



~~~
methyl_mat <- t(assay(methylation))
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 't': error in evaluating the argument 'x' in selecting a method for function 'assay': object 'methylation' not found
~~~
{: .error}



~~~
age <- methylation$Age
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'methylation' not found
~~~
{: .error}

# Why would we want to do feature selection?

In the previous lesson we did a kind of feature selection by doing
univariate analysis and thresholding by p-value/effect size.


However we might think there's some combination of methylation features
that combined explain age. For example, if we want to be able to predict age 
from methylation, that's a lot easier if we figure out what the contribution
of each feature is conditional on all others, rather than independent of
all others.

$$
    y_j = \beta_0 + \beta_1 X_1 + \dots \beta_p X_p + \epsilon_j
$$

However when the number of predictors is greater than the number of samples
(basically always true in genetics) it isn't possible to include everything!

What happens if we try to fit a model here?


~~~
fit <- lm(age ~ methyl_mat)
~~~
{: .language-r}



~~~
Error in eval(predvars, data, env): object 'age' not found
~~~
{: .error}



~~~
summary(fit)
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'fit' not found
~~~
{: .error}

So we can't do that mathematically, we have to find another way.

# Screening

What people sometimes do is to select variables based on correlation with
the outcome, or using a univariate modelling approach like we used in the 
previous lesson.
There's some problems with this! First, the p-values we get out of the final
model are meaningless because we're basically doing a 2-stage model and only
reporting one set of p-values (ignoring all the non-significant ones).
Secondly, we're likely to select a bunch of features that all have the same 
information!


~~~
nvar <- 1000
nobs <- 100
y_synth <- rnorm(nobs)
synth_mat <- matrix(rnorm(nobs * nvar), nrow = nobs, ncol = nvar)
cors <- apply(synth_mat, 2, function(col) cor(col, y_synth))
X_pred <- synth_mat[, abs(cors) > quantile(abs(cors), 0.99)]
summary(lm(y_synth ~ ., data = as.data.frame(X_pred)))
~~~
{: .language-r}



~~~

Call:
lm(formula = y_synth ~ ., data = as.data.frame(X_pred))

Residuals:
     Min       1Q   Median       3Q      Max 
-1.52126 -0.39983 -0.06845  0.35397  1.53089 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) -0.07345    0.07074  -1.038  0.30190    
V1          -0.24762    0.08297  -2.984  0.00367 ** 
V2           0.32665    0.06858   4.763 7.37e-06 ***
V3           0.22532    0.06917   3.258  0.00159 ** 
V4          -0.19275    0.06921  -2.785  0.00654 ** 
V5           0.17612    0.06289   2.800  0.00626 ** 
V6           0.15285    0.08573   1.783  0.07802 .  
V7           0.13310    0.07115   1.871  0.06467 .  
V8           0.16824    0.07967   2.112  0.03751 *  
V9          -0.15644    0.07539  -2.075  0.04086 *  
V10          0.19829    0.07529   2.634  0.00996 ** 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.6853 on 89 degrees of freedom
Multiple R-squared:  0.5734,	Adjusted R-squared:  0.5255 
F-statistic: 11.96 on 10 and 89 DF,  p-value: 8.048e-13
~~~
{: .output}

Amazing, the results are highly significant! However this isn't rigorous and
can lead to problems so don't do it!


# Best subset selection

However, we could imagine trying each combination of features to find which
is the best combination. This works, but is really computationally demanding,
because blah blah number of permutations probably $p!$ but need to check.



~~~
library("leaps")
small_methyl <- methyl_mat[, 1:10]
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'methyl_mat' not found
~~~
{: .error}



~~~
fit_all <- regsubsets(x = small_methyl, y = age, really.big = TRUE)
~~~
{: .language-r}



~~~
Error in regsubsets(x = small_methyl, y = age, really.big = TRUE): object 'small_methyl' not found
~~~
{: .error}



~~~
summ <- summary(fit_all)
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'fit_all' not found
~~~
{: .error}



~~~
coef(fit_all, which.min(summ$rss))
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'coef': object 'fit_all' not found
~~~
{: .error}

Let's try running BS on the full dataset.


~~~
fit_all <- regsubsets(x = methyl_mat, y = age, really.big = TRUE)
summ <- summary(fit_all)
coef(fit_all, which.min(summ$rss))
~~~
{: .language-r}

This doesn't really work in a reasonable time because of the number of possible
combinations!

<img src="../fig/bs_fs.png" title="plot of chunk bstab" alt="plot of chunk bstab" width="500px" style="display: block; margin: auto;" />

Figure taken from [Hastie et al. (2020)](https://www.stat.cmu.edu/~ryantibs/papers/bestsubset.pdf),
published [here](https://doi.org/10.1214/19-STS733).


# Model metrics

In the example above we used RSS (residual sum of squares) to choose a model.
However when comparing models with different numbers of features, this is
problematic. We could, for example, keep adding features that marginally 
reduce the RSS (because adding a feature will never make it worse!) and
under this framework we'll always select the biggest model.

For example, if we have as many features as observations, the fit is always
perfect.


~~~
nvar <- 100
nobs <- 100
y_synth <- rnorm(nobs)
X_synth <- matrix(rnorm(nobs * nvar), nrow = nobs, ncol = nvar)
fit <- lm(y_synth ~ 0 + ., data = as.data.frame(X_synth))
sum(residuals(fit)^2)
~~~
{: .language-r}



~~~
[1] 0
~~~
{: .output}

There are other ways to measure model performance while accounting for the
complexity of the model. For example, adjusted $R^2$ is similar to the normal
R^2 measure that estimates the variation explained by the model, while also
accounting for the number of features. This is explained
in more detail in [the multiple regression lesson](https://carpentries-incubator.github.io/multiple-linear-regression-public-health/)

BIC and AIC also exist. There's also an issue of how well these things
will generalise beyond the present dataset.

> ## Exercise
>
> Select the best model based on BIC. How does this differ to the best RSS 
> model?
> 
> > ## Solution
> > 
> > 
> > 
> > ~~~
> > coef(fit_all, id = which.min(summ$bic))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'coef': object 'fit_all' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > coef(fit_all, id = which.min(summ$rss))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'coef': object 'fit_all' not found
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}


# Forward stepwise selection

Since BS is computationally hard, we can instead do an approximation.
One of these is forward stepwise selection.

Basically:

1. pick the most significant feature
2. fit a model with that feature and every other
3. if any are a significant improvement, pick the model that has the best improvement
   and return to 2.
4. otherwise stop

Here we apply it to a synthetic methylation dataset where we know the true
predictors.


~~~
## challenge 4: forward selection
## compare with true betas
if (!file.exists(here("data/synthetic.rds"))) {
  source(here("data/synthetic.R"))
}
~~~
{: .language-r}



~~~
Error in validObject(.Object): invalid class "SummarizedExperiment" object: 
    'x@assays' is not parallel to 'x'
~~~
{: .error}



~~~
synthetic <- readRDS(here("data/synthetic.rds"))
~~~
{: .language-r}



~~~
Warning in gzfile(file, "rb"): cannot open compressed file '/home/runner/work/
high-dimensional-stats-r/high-dimensional-stats-r/data/synthetic.rds', probable
reason 'No such file or directory'
~~~
{: .warning}



~~~
Error in gzfile(file, "rb"): cannot open the connection
~~~
{: .error}



~~~
synth_mat <- t(assay(synthetic))
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 't': error in evaluating the argument 'x' in selecting a method for function 'assay': object 'synthetic' not found
~~~
{: .error}



~~~
synth_age <- synthetic$age
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'synthetic' not found
~~~
{: .error}



~~~
fit_forward <- regsubsets(x = synth_mat, y = synth_age, method = "forward")
~~~
{: .language-r}



~~~
Error in leaps.setup(x, y, wt = weights, nbest = nbest, nvmax = nvmax, : object 'synth_age' not found
~~~
{: .error}



~~~
summ_forward <- summary(fit_forward)
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'fit_forward' not found
~~~
{: .error}



~~~
est_coef_fwd <- coef(fit_forward, id = which.min(summ_forward$bic))
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'coef': object 'fit_forward' not found
~~~
{: .error}



~~~
true_coefs <- rowData(synthetic)[names(est_coef_fwd)[-1], "true_beta"]
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'rowData': object 'synthetic' not found
~~~
{: .error}



~~~
true_coefs
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'true_coefs' not found
~~~
{: .error}



~~~
est_coef_fwd
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'est_coef_fwd' not found
~~~
{: .error}



~~~
all_coefs <- c(true_coefs, est_coef_fwd[-1])
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'true_coefs' not found
~~~
{: .error}



~~~
plot(true_coefs, est_coef_fwd[-1], xlim = range(all_coefs), ylim = range(all_coefs))
~~~
{: .language-r}



~~~
Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': object 'true_coefs' not found
~~~
{: .error}



~~~
abline(0, 1)
~~~
{: .language-r}



~~~
Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet
~~~
{: .error}



~~~
abline(v = 0, lty = "dashed", col = "firebrick")
~~~
{: .language-r}



~~~
Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet
~~~
{: .error}



~~~
abline(h = 0, lty = "dashed", col = "firebrick")
~~~
{: .language-r}



~~~
Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet
~~~
{: .error}






> ## Exercise
> Perform forward subset selection on the methylation data.
> 
> Check the BICs. Select the best model based on BIC.
>
> > ## Solution
> > 
> > 
> > ~~~
> > ## challenge 4: forward selection
> > fit_forward <- regsubsets(x = methyl_mat, y = age, method = "forward")
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in regsubsets(x = methyl_mat, y = age, method = "forward"): object 'methyl_mat' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > summ_forward <- summary(fit_forward)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'fit_forward' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > est_coef_fwd <- coef(fit_forward, id = which.min(summ_forward$bic))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'coef': object 'fit_forward' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > est_coef_fwd
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in eval(expr, envir, enclos): object 'est_coef_fwd' not found
> > ~~~
> > {: .error}
> > 
> {: .solution}
{: .challenge}


# Reverse stepwise selection

If we have a model that we think is real and we want to slim it down, we
can do reverse subset selection.

`methylclock::coefHorvath` is the Horvath methylation age predictor
[Horvath (2013)](https://pubmed.ncbi.nlm.nih.gov/24138928/).


> ## Exercise
> 
> Do reverse subset selection and compare with the forward and reverse model.
> 
> > ## Solution
> >
> > 
> > ~~~
> > features <- methylclock::coefHorvath$CpGmarker
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in loadNamespace(x): there is no package called 'methylclock'
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > features <- intersect(features, colnames(methyl_mat))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'intersect': object 'features' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > methyl_horvath <- methyl_mat[, features[1:30]]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in eval(expr, envir, enclos): object 'methyl_mat' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > ## note about backward/both, not a challenge
> > fit_back <- regsubsets(x = methyl_horvath, y = age, method = "backward")
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in regsubsets(x = methyl_horvath, y = age, method = "backward"): object 'methyl_horvath' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > summ_back <- summary(fit_back)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'fit_back' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > summ_back$bic
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in eval(expr, envir, enclos): object 'summ_back' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > est_coef_back <- coef(fit_back, id = which.min(summ_back$bic))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'coef': object 'fit_back' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > true_coef <- setNames(
> >   methylclock::coefHorvath$CoefficientTraining,
> >   methylclock::coefHorvath$CpGmarker
> > )
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in loadNamespace(x): there is no package called 'methylclock'
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > plot(est_coef_back[-1], true_coef[names(est_coef_back)[-1]])
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': object 'est_coef_back' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > abline(0, 1)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > abline(v = 0, lty = "dashed", col = "firebrick")
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > abline(h = 0, lty = "dashed", col = "firebrick")
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > names(est_coef_back[-1])
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in eval(expr, envir, enclos): object 'est_coef_back' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > names(est_coef_fwd[-1])
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in eval(expr, envir, enclos): object 'est_coef_fwd' not found
> > ~~~
> > {: .error}
> > 
> > 
> > 
> > ~~~
> > intersect(names(est_coef_back[-1]), names(est_coef_fwd[-1]))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'intersect': object 'est_coef_back' not found
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}




{% include links.md %}
